
let ioredis = require("ioredis");
let config = require('../Config.es6');

let client = new ioredis(config.redis.port, config.redis.host);


let never = () => { throw new Error('Should never happen'); };
let keys = {
	get SESSION_LAST_INSERT_ID() { never() },
	get SESSION_ACTIVES() { never() },
	get SESSION_BY_CONTEXT() { never() },
	get SESSION_TO_RECORD() { never() },
};
// to avoid explicitly setting value for
// each constant risking getting a typo
for (let key in keys) {
	delete keys[key];
	keys[key] = 'GRECT_' + key;
}

exports.keys = keys;

exports.client = {
	// I hope all of them are implemented in ioredis
	append: (...args) => Promise.resolve().then(() => client.append(args)),
	auth: (...args) => Promise.resolve().then(() => client.auth(args)),
	bgrewriteaof: (...args) => Promise.resolve().then(() => client.bgrewriteaof(args)),
	bgsave: (...args) => Promise.resolve().then(() => client.bgsave(args)),
	bitcount: (...args) => Promise.resolve().then(() => client.bitcount(args)),
	bitfield: (...args) => Promise.resolve().then(() => client.bitfield(args)),
	bitop: (...args) => Promise.resolve().then(() => client.bitop(args)),
	bitpos: (...args) => Promise.resolve().then(() => client.bitpos(args)),
	blpop: (...args) => Promise.resolve().then(() => client.blpop(args)),
	brpop: (...args) => Promise.resolve().then(() => client.brpop(args)),
	brpoplpush: (...args) => Promise.resolve().then(() => client.brpoplpush(args)),
	bzpopmin: (...args) => Promise.resolve().then(() => client.bzpopmin(args)),
	bzpopmax: (...args) => Promise.resolve().then(() => client.bzpopmax(args)),
	dbsize: (...args) => Promise.resolve().then(() => client.dbsize(args)),
	decr: (...args) => Promise.resolve().then(() => client.decr(args)),
	decrby: (...args) => Promise.resolve().then(() => client.decrby(args)),
	del: (...args) => Promise.resolve().then(() => client.del(args)),
	discard: (...args) => Promise.resolve().then(() => client.discard(args)),
	dump: (...args) => Promise.resolve().then(() => client.dump(args)),
	echo: (...args) => Promise.resolve().then(() => client.echo(args)),
	eval: (...args) => Promise.resolve().then(() => client.eval(args)),
	evalsha: (...args) => Promise.resolve().then(() => client.evalsha(args)),
	exec: (...args) => Promise.resolve().then(() => client.exec(args)),
	exists: (...args) => Promise.resolve().then(() => client.exists(args)),
	expire: (...args) => Promise.resolve().then(() => client.expire(args)),
	expireat: (...args) => Promise.resolve().then(() => client.expireat(args)),
	flushall: (...args) => Promise.resolve().then(() => client.flushall(args)),
	flushdb: (...args) => Promise.resolve().then(() => client.flushdb(args)),
	geoadd: (...args) => Promise.resolve().then(() => client.geoadd(args)),
	geohash: (...args) => Promise.resolve().then(() => client.geohash(args)),
	geopos: (...args) => Promise.resolve().then(() => client.geopos(args)),
	geodist: (...args) => Promise.resolve().then(() => client.geodist(args)),
	georadius: (...args) => Promise.resolve().then(() => client.georadius(args)),
	georadiusbymember: (...args) => Promise.resolve().then(() => client.georadiusbymember(args)),
	get: (...args) => Promise.resolve().then(() => client.get(args)),
	getbit: (...args) => Promise.resolve().then(() => client.getbit(args)),
	getrange: (...args) => Promise.resolve().then(() => client.getrange(args)),
	getset: (...args) => Promise.resolve().then(() => client.getset(args)),
	hdel: (...args) => Promise.resolve().then(() => client.hdel(args)),
	hexists: (...args) => Promise.resolve().then(() => client.hexists(args)),
	hget: (...args) => Promise.resolve().then(() => client.hget(args)),
	hgetall: (...args) => Promise.resolve().then(() => client.hgetall(args)),
	hincrby: (...args) => Promise.resolve().then(() => client.hincrby(args)),
	hincrbyfloat: (...args) => Promise.resolve().then(() => client.hincrbyfloat(args)),
	hkeys: (...args) => Promise.resolve().then(() => client.hkeys(args)),
	hlen: (...args) => Promise.resolve().then(() => client.hlen(args)),
	hmget: (...args) => Promise.resolve().then(() => client.hmget(args)),
	hmset: (...args) => Promise.resolve().then(() => client.hmset(args)),
	hset: (...args) => Promise.resolve().then(() => client.hset(args)),
	hsetnx: (...args) => Promise.resolve().then(() => client.hsetnx(args)),
	hstrlen: (...args) => Promise.resolve().then(() => client.hstrlen(args)),
	hvals: (...args) => Promise.resolve().then(() => client.hvals(args)),
	incr: (...args) => Promise.resolve().then(() => client.incr(args)),
	incrby: (...args) => Promise.resolve().then(() => client.incrby(args)),
	incrbyfloat: (...args) => Promise.resolve().then(() => client.incrbyfloat(args)),
	info: (...args) => Promise.resolve().then(() => client.info(args)),
	keys: (...args) => Promise.resolve().then(() => client.keys(args)),
	lastsave: (...args) => Promise.resolve().then(() => client.lastsave(args)),
	lindex: (...args) => Promise.resolve().then(() => client.lindex(args)),
	linsert: (...args) => Promise.resolve().then(() => client.linsert(args)),
	llen: (...args) => Promise.resolve().then(() => client.llen(args)),
	lpop: (...args) => Promise.resolve().then(() => client.lpop(args)),
	lpush: (...args) => Promise.resolve().then(() => client.lpush(args)),
	lpushx: (...args) => Promise.resolve().then(() => client.lpushx(args)),
	lrange: (...args) => Promise.resolve().then(() => client.lrange(args)),
	lrem: (...args) => Promise.resolve().then(() => client.lrem(args)),
	lset: (...args) => Promise.resolve().then(() => client.lset(args)),
	ltrim: (...args) => Promise.resolve().then(() => client.ltrim(args)),
	mget: (...args) => Promise.resolve().then(() => client.mget(args)),
	migrate: (...args) => Promise.resolve().then(() => client.migrate(args)),
	monitor: (...args) => Promise.resolve().then(() => client.monitor(args)),
	move: (...args) => Promise.resolve().then(() => client.move(args)),
	mset: (...args) => Promise.resolve().then(() => client.mset(args)),
	msetnx: (...args) => Promise.resolve().then(() => client.msetnx(args)),
	multi: (...args) => Promise.resolve().then(() => client.multi(args)),
	object: (...args) => Promise.resolve().then(() => client.object(args)),
	persist: (...args) => Promise.resolve().then(() => client.persist(args)),
	pexpire: (...args) => Promise.resolve().then(() => client.pexpire(args)),
	pexpireat: (...args) => Promise.resolve().then(() => client.pexpireat(args)),
	pfadd: (...args) => Promise.resolve().then(() => client.pfadd(args)),
	pfcount: (...args) => Promise.resolve().then(() => client.pfcount(args)),
	pfmerge: (...args) => Promise.resolve().then(() => client.pfmerge(args)),
	ping: (...args) => Promise.resolve().then(() => client.ping(args)),
	psetex: (...args) => Promise.resolve().then(() => client.psetex(args)),
	psubscribe: (...args) => Promise.resolve().then(() => client.psubscribe(args)),
	pubsub: (...args) => Promise.resolve().then(() => client.pubsub(args)),
	pttl: (...args) => Promise.resolve().then(() => client.pttl(args)),
	publish: (...args) => Promise.resolve().then(() => client.publish(args)),
	punsubscribe: (...args) => Promise.resolve().then(() => client.punsubscribe(args)),
	quit: (...args) => Promise.resolve().then(() => client.quit(args)),
	randomkey: (...args) => Promise.resolve().then(() => client.randomkey(args)),
	readonly: (...args) => Promise.resolve().then(() => client.readonly(args)),
	readwrite: (...args) => Promise.resolve().then(() => client.readwrite(args)),
	rename: (...args) => Promise.resolve().then(() => client.rename(args)),
	renamenx: (...args) => Promise.resolve().then(() => client.renamenx(args)),
	restore: (...args) => Promise.resolve().then(() => client.restore(args)),
	role: (...args) => Promise.resolve().then(() => client.role(args)),
	rpop: (...args) => Promise.resolve().then(() => client.rpop(args)),
	rpoplpush: (...args) => Promise.resolve().then(() => client.rpoplpush(args)),
	rpush: (...args) => Promise.resolve().then(() => client.rpush(args)),
	rpushx: (...args) => Promise.resolve().then(() => client.rpushx(args)),
	sadd: (...args) => Promise.resolve().then(() => client.sadd(args)),
	save: (...args) => Promise.resolve().then(() => client.save(args)),
	scard: (...args) => Promise.resolve().then(() => client.scard(args)),
	sdiff: (...args) => Promise.resolve().then(() => client.sdiff(args)),
	sdiffstore: (...args) => Promise.resolve().then(() => client.sdiffstore(args)),
	select: (...args) => Promise.resolve().then(() => client.select(args)),
	set: (...args) => Promise.resolve().then(() => client.set(args)),
	setbit: (...args) => Promise.resolve().then(() => client.setbit(args)),
	setex: (...args) => Promise.resolve().then(() => client.setex(args)),
	setnx: (...args) => Promise.resolve().then(() => client.setnx(args)),
	setrange: (...args) => Promise.resolve().then(() => client.setrange(args)),
	shutdown: (...args) => Promise.resolve().then(() => client.shutdown(args)),
	sinter: (...args) => Promise.resolve().then(() => client.sinter(args)),
	sinterstore: (...args) => Promise.resolve().then(() => client.sinterstore(args)),
	sismember: (...args) => Promise.resolve().then(() => client.sismember(args)),
	slaveof: (...args) => Promise.resolve().then(() => client.slaveof(args)),
	replicaof: (...args) => Promise.resolve().then(() => client.replicaof(args)),
	slowlog: (...args) => Promise.resolve().then(() => client.slowlog(args)),
	smembers: (...args) => Promise.resolve().then(() => client.smembers(args)),
	smove: (...args) => Promise.resolve().then(() => client.smove(args)),
	sort: (...args) => Promise.resolve().then(() => client.sort(args)),
	spop: (...args) => Promise.resolve().then(() => client.spop(args)),
	srandmember: (...args) => Promise.resolve().then(() => client.srandmember(args)),
	srem: (...args) => Promise.resolve().then(() => client.srem(args)),
	strlen: (...args) => Promise.resolve().then(() => client.strlen(args)),
	subscribe: (...args) => Promise.resolve().then(() => client.subscribe(args)),
	sunion: (...args) => Promise.resolve().then(() => client.sunion(args)),
	sunionstore: (...args) => Promise.resolve().then(() => client.sunionstore(args)),
	swapdb: (...args) => Promise.resolve().then(() => client.swapdb(args)),
	sync: (...args) => Promise.resolve().then(() => client.sync(args)),
	time: (...args) => Promise.resolve().then(() => client.time(args)),
	touch: (...args) => Promise.resolve().then(() => client.touch(args)),
	ttl: (...args) => Promise.resolve().then(() => client.ttl(args)),
	type: (...args) => Promise.resolve().then(() => client.type(args)),
	unsubscribe: (...args) => Promise.resolve().then(() => client.unsubscribe(args)),
	unlink: (...args) => Promise.resolve().then(() => client.unlink(args)),
	unwatch: (...args) => Promise.resolve().then(() => client.unwatch(args)),
	wait: (...args) => Promise.resolve().then(() => client.wait(args)),
	watch: (...args) => Promise.resolve().then(() => client.watch(args)),
	zadd: (...args) => Promise.resolve().then(() => client.zadd(args)),
	zcard: (...args) => Promise.resolve().then(() => client.zcard(args)),
	zcount: (...args) => Promise.resolve().then(() => client.zcount(args)),
	zincrby: (...args) => Promise.resolve().then(() => client.zincrby(args)),
	zinterstore: (...args) => Promise.resolve().then(() => client.zinterstore(args)),
	zlexcount: (...args) => Promise.resolve().then(() => client.zlexcount(args)),
	zpopmax: (...args) => Promise.resolve().then(() => client.zpopmax(args)),
	zpopmin: (...args) => Promise.resolve().then(() => client.zpopmin(args)),
	zrange: (...args) => Promise.resolve().then(() => client.zrange(args)),
	zrangebylex: (...args) => Promise.resolve().then(() => client.zrangebylex(args)),
	zrevrangebylex: (...args) => Promise.resolve().then(() => client.zrevrangebylex(args)),
	zrangebyscore: (...args) => Promise.resolve().then(() => client.zrangebyscore(args)),
	zrank: (...args) => Promise.resolve().then(() => client.zrank(args)),
	zrem: (...args) => Promise.resolve().then(() => client.zrem(args)),
	zremrangebylex: (...args) => Promise.resolve().then(() => client.zremrangebylex(args)),
	zremrangebyrank: (...args) => Promise.resolve().then(() => client.zremrangebyrank(args)),
	zremrangebyscore: (...args) => Promise.resolve().then(() => client.zremrangebyscore(args)),
	zrevrange: (...args) => Promise.resolve().then(() => client.zrevrange(args)),
	zrevrangebyscore: (...args) => Promise.resolve().then(() => client.zrevrangebyscore(args)),
	zrevrank: (...args) => Promise.resolve().then(() => client.zrevrank(args)),
	zscore: (...args) => Promise.resolve().then(() => client.zscore(args)),
	zunionstore: (...args) => Promise.resolve().then(() => client.zunionstore(args)),
	scan: (...args) => Promise.resolve().then(() => client.scan(args)),
	sscan: (...args) => Promise.resolve().then(() => client.sscan(args)),
	hscan: (...args) => Promise.resolve().then(() => client.hscan(args)),
	zscan: (...args) => Promise.resolve().then(() => client.zscan(args)),
	xinfo: (...args) => Promise.resolve().then(() => client.xinfo(args)),
	xadd: (...args) => Promise.resolve().then(() => client.xadd(args)),
	xtrim: (...args) => Promise.resolve().then(() => client.xtrim(args)),
	xdel: (...args) => Promise.resolve().then(() => client.xdel(args)),
	xrange: (...args) => Promise.resolve().then(() => client.xrange(args)),
	xrevrange: (...args) => Promise.resolve().then(() => client.xrevrange(args)),
	xlen: (...args) => Promise.resolve().then(() => client.xlen(args)),
	xread: (...args) => Promise.resolve().then(() => client.xread(args)),
	xgroup: (...args) => Promise.resolve().then(() => client.xgroup(args)),
	xreadgroup: (...args) => Promise.resolve().then(() => client.xreadgroup(args)),
	xack: (...args) => Promise.resolve().then(() => client.xack(args)),
	xclaim: (...args) => Promise.resolve().then(() => client.xclaim(args)),
	xpending: (...args) => Promise.resolve().then(() => client.xpending(args)),
};