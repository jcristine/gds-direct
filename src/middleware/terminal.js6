'use strict';

let $					= require('jquery');
window.$ 				= window.jQuery = $;

require('jquery.terminal/js/jquery.terminal');
require('keyboardevent-key-polyfill').polyfill();

import Noty 		from 'noty';
import Helpers 		from '../helpers/helpers';
import Pagination 	from '../modules/pagination';
import Session 		from '../modules/sabreSession';
import Spinner 		from '../modules/spinner';
import KeyBinding	from '../helpers/keyBinding';
import OutputLiner	from '../modules/output';
import TabManager	from '../modules/tabManager';
import F8Reader		from '../modules/f8';

const Debug = txt => {
	new Noty({
		text	: `DEBUG : ${txt}`,
		layout 	: 'bottomRight',
		timeout : 1000,
		theme	: 'relax',
		type 	: 'warning'
	}).show();
};

export default class TerminalPlugin
{
	constructor( params )
	{
		this.settings 	= params;
		this.context	= params.context;
		this.name		= params.name;

		this.hiddenBuff		= [];
		// this.hiddenCommand	= '';

		this.allowManualPaging = params.gds === 'sabre';

		this.session = new Session({
			terminalIndex	: params.name,
			sessionIndex	: params.sessionIndex,
			gds				: params.gds
		});

		this.terminal 		= this.init();

		this.pagination 	= new Pagination( this.terminal );
		this.spinner 		= new Spinner( this.terminal );
		this.outputLiner 	= new OutputLiner( this.terminal );
		this.tabCommands	= new TabManager();
		this.f8Reader		= new F8Reader( this.terminal );
	}

	parseChar( evt, terminal )
	{
		// key press fires globally on all terminals;

		if ( evt.target.nodeName !== 'TEXTAREA' )
			return undefined;

		if ( terminal.cmd().find('textarea')[0] !== evt.target )
			return undefined;

		if ( !terminal.enabled() )
			return undefined;

		const ch = Helpers.substitutePrintableChar( evt, window.TerminalState.isLanguageApollo() );

		if (!ch) // don't insert empty char further
		{
			return false;
		}

		if ( this.f8Reader.getIsActive() )
		{
			this.f8Reader.keyPressed( ch );
			return false;
		}

		terminal.insert( ch );
		return false;
	}

	parseKeyBinds( evt, terminal )
	{
		// let keyCode = evt.keyCode || evt.which;
		// if (keyCode === 13)
		// {
		// 	return false;
		// }
		/*if ( this.spinner.isActive() && keyCode === 13 )
		{
			this.hiddenBuff.push( this.hiddenCommand );
			this.hiddenCommand = '';

			return false;
		}*/

		// const cmd = KeyBinding.parse( evt, terminal );

		if ( !KeyBinding.parse( evt, terminal ) )
			return false;
	}

	switchArea( command )
	{
		const sessionIndex = window.TerminalState.getSessionAreaMap().indexOf( command );

		if ( sessionIndex !== -1 )
		{
			window.TerminalState.change({ sessionIndex }, 'CHANGE_SESSION');
		}
	}

	changeActiveTerm( activeTerminal )
	{
		window.TerminalState.change({ activeTerminal }, 'CHANGE_ACTIVE_TERMINAL');
	}

	clearBuf()
	{
		// this.session
		// 	.clearBuffer();

		window.TerminalState.purgeScreens();
	}

	tabPressed()
	{
		if ( this.f8Reader.getIsActive() )
		{
			this.f8Reader.tabPressed();
			return false;
		}

		const replace = terminal => {

			return ( [cmd, formatted] ) => {
				terminal.cmd().set( cmd );
				terminal.update( terminal.last_index(), formatted );
			}

		};

		this.tabCommands.run( replace(this.terminal) );
	}

	resize( w, h )
	{
		this.terminal.resize( w, h );
		// this.terminal.resize();
		// this.outputLiner.recalculate();
	}

	emptyLinesRecalculate()
	{
		this.outputLiner.recalculate();
	}

	init()
	{
		return $(this.context).terminal( this.commandParser.bind(this), {

			greetings		: '',
			name			: this.name,
			prompt			: '>',

			// scrollOnEcho	: false,
			keypress		: this.parseChar.bind(this), // BUGGY BUGGY, assign on document wtf???
			keydown			: this.parseKeyBinds.bind(this),

			onInit			: this.changeActiveTerm,
			onTerminalChange: this.changeActiveTerm,

			memory			: true,

			onBeforeCommand : ( terminal, command ) => { // is using
				if ( this.spinner.isActive()  )
				{
					this.hiddenBuff.push( command );
					return false;
				}
			},

			// for hard scenario shortcut, others in keymap helper
			keymap			: {
				'CTRL+S'	: () => this.clearBuf(),
				'TAB'		: () => this.tabPressed(),
				'F8'		: () => this.f8Reader.tie(),
			},

			exceptionHandler( err )
			{
				console.warn('exc', err)
			}
		});
	}

	commandParser( command, terminal ) //pressed enter
	{
		this.outputLiner.prepare('');

		if ( !command || command === '' )
			return false;

		if ( this.allowManualPaging )
		{
			switch (command)
			{
				case 'MD' :
					terminal.echo( this.pagination.next().print() );
				return false;

				case 'MU' :
					terminal.echo( this.pagination.prev().print() );
				return false;

				case 'MDA' :
					terminal.echo( this.pagination.printAll() );
				return false;

				case 'MDA5' :
					return false;

				case 'MDA20' :
					return false;
			}
		}

		this.spinner.start();

		// this.outputLiner.prepare( '' );

		/*setTimeout( () => {
			this.spinner.end();
			this.loopCmdStack();
			this.parseBackEnd({
				data	: {
					output 		: 'THIS IS ONLY A TEST TEST TES TEST',
					clearScreen : true
				}
			})
		}, 1000 );*/

		this.sendRequest(command);

		return false;
	}

	loopCmdStack()
	{
		if (this.hiddenBuff.length)
		{
			const cmd = this.hiddenBuff.shift();

			if ( cmd )
				this.terminal.exec( cmd );
		}
	}

	sendRequest( command )
	{
		this.session
			.run({
				cmd : command
			})

			.then( response => {
				this.spinner.end();
				return response;
			})

			.then( this.parseBackEnd.bind(this) )
			.then( () => {
				this.loopCmdStack();
				this.switchArea( command );
			})
			.catch( this.parseError.bind(this) );
	}

	parseBackEnd( response = {} )
	{
		const result = response['data'] || {};

		if ( result['output'] )
		{
			if ( this.allowManualPaging ) // sabre
			{
				const output = this.pagination
					.bindOutput( result['output'], this.terminal.rows() - 1, this.terminal.cols() )
					.print();

				this.terminal.echo( output );
			} else
			{
				const clearScreen = result['clearScreen'] && window.TerminalState.getMatrix().rows !== 0;

				this.outputLiner
					.prepare( result['output'], clearScreen );
			}
		}

		this.tabCommands.reset( result['tabCommands'], result['output'] );

		if ( result['pcc'] )
			window.TerminalState.change({pcc : result['pcc']}, 'CHANGE_PCC');

		this.debugOutput( result );
	}

	debugOutput( result )
	{
		if (result['clearScreen'])
			Debug( 'DEBUG: CLEAR SCREEN' );

		if ( result['canCreatePq'] )
			Debug( 'CAN CREATE PCC' );

		if ( result['tabCommands'] && result['tabCommands'].length )
			Debug( 'FOUND TAB COMMANDS' );
	}
	
	parseError(e)
	{
		this.spinner.end();
		console.error(' error', arguments );
		this.terminal.error( String(e) );
	}
}